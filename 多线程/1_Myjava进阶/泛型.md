# 泛型

## 泛型的使用

```java
package com.atguigu.demo;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

import com.atguigu.bean.Person;

/**
 * 此类用于演示  泛型的使用[如何使用泛型]
 * 1. 泛型的概念？   贴标签
 * 	JDK1.5设计了泛型的概念。泛型即为“类型参数”，
 *   这个类型参数在声明它的类、接口或方法中，代表未知的通用的类型
 * 2. 泛型的使用和泛型的好处
 * 	 2.1 泛型的使用
 * 		a. 使用在集合上
 * 			语法：List<泛型类型> list=new ArrayList<泛型类型>();
 * 			例子：List<String> list=new ArrayList<String>();
 * 				注意事项：
 * 					①  泛型不能用基本数据类型(用包装类)
 * 					②  泛型不存在多态(前后要保持一致)后面的泛型可以省略 jdk1.7开始支持的
 *   	b. 泛型并不是集合专属的，在接口、类上、方法上都可以使用泛型
 *   		用在了Comparable<Person>上
 *   2.2 泛型的好处
 *   	a. 节省代码，减少向下转型(避免异常的产生)
 *   
 * 下节课，还要在举一个例子(和Comparable<T>，Comparator<T>)
 * 
 * 泛型的使用应该掌握了！
 *
 */
public class Demo1{

	public static void main(String[] args) {
		List<String> list=new ArrayList<String>();//生产了一个空瓶子(指定该容器存储字符串)
		//泛型是干什么？   确定这个瓶子中存储什么类型的数据  String
		list.add("java");
		list.get(0);
		
		List<Integer> list1=new ArrayList<Integer>();
		list1.add(100);
		
		//test4();
		test3();
		
	}
	/*
	 * 练习的讲解：泛型在其他接口(Comparator)上的使用
	 */
	public static void test4(){
		List<Person> pers=new ArrayList<>();
		pers.add(new Person(101, "老韩", 18));
		pers.add(new Person(102, "蔡徐坤", 28));
		pers.add(new Person(103, "卢本伟", 19));
		pers.add(new Person(104, "谢广坤", 28));
		pers.add(new Person(105, "宋喆", 38));
		
		Collections.sort(pers, new Comparator<Person>() {
			@Override
			public int compare(Person o1, Person o2) {
				return o1.getAge()-o2.getAge();
			}//匿名内部类
		});
		
		//如果自然排序和定制排序同时存在会以哪个为准呢？是以定制排序为准
		for (Person person : pers) {
			System.out.println(person);
		}
	}
	/*
	 * 
	 * 验证有无泛型的区别
	 * 并且学习泛型在比较器上的使用
	 * 需求：有一个Person类，属性：id,name,age
	 * 创建一个List集合，在集合中存放5个Person对象
	 * ①：通过Collections中sort(List list)  对list集合进行排序的 [要求使用泛型]
	   ②：通过Collections中sort(List list,Comparator c)[定制排序]--要求使用泛型
	 	锻炼泛型的使用，锻炼泛型在其他接口上的使用
	 */
	@SuppressWarnings({ "unchecked", "rawtypes" })
	public static void test3(){
//		1. 不使用泛型的
		/*List pers=new ArrayList(); 
		pers.add(new Person(101, "老韩", 18));
		pers.add(new Person(102, "蔡徐坤", 28));
		pers.add(new Person(103, "卢本伟", 19));
		pers.add(new Person(104, "谢广坤", 28));
		pers.add(new Person(105, "宋喆", 38));
		
		Collections.sort(pers);
		//对集合进行排序，这5个Person谁大谁小？根据什么判断谁大谁小呢？
		//实现接口-->Person类要实现自然排序
		for (Object obj : pers) {
			System.out.println(obj);
		}*/
		//2. 使用泛型
		List<Person> pers=new ArrayList<>();
		pers.add(new Person(101, "老韩", 18));
		pers.add(new Person(102, "蔡徐坤", 28));
		pers.add(new Person(103, "卢本伟", 19));
		pers.add(new Person(104, "谢广坤", 28));
		pers.add(new Person(105, "宋喆", 38));
		
		Collections.sort(pers);//由于将自然排序删除了，所以此处有个错误
		
		for (Person person : pers) {
			System.out.println(person);
		}
	}
	/*
	 * 深入研究泛型的使用
	 */
	public static void test2(){
		//是否可以用自定义的类型
		List<Animal> list=new ArrayList<>();
		//list集合的泛型是Animal,是否可以添加Dog对象？可以    多态
		list.add(new Dog());
	}
	/*
	 * 1. 需求：创建一个List集合，存储5个字符串
	 *    循环打印出这些字符串的长度
	 */
	@SuppressWarnings({ "unchecked", "rawtypes" })
	public static void test1(){
		//1. 不用泛型
		/*List list1=new ArrayList();
		list1.add("java");
		list1.add("python");
		list1.add("mysql");
		list1.add("Oracle");
		list1.add(100);
		
		for (Object obj : list1) {
			if(obj instanceof String){
				String str=(String)obj;//①
				System.out.println(str.length());//Object没有length方法，① 向下转型②调用toString方法
			}
		}*/
		//2. 用泛型   ① 泛型如何使用？② 泛型的好处？
		List<String> list1=new ArrayList<String>();//保证此集合中所有的数据都是String
		list1.add("java");
		list1.add("python");
		list1.add("mysql");
		list1.add("Oracle");
		list1.add("go");
//		循环打印出这些字符串的长度
		/*
		 * 1. 从list1集合中取出的数据类型直接就是String类型
		 * 2. 因为list1使用泛型了，就能保证里面全部都是String类型
		 */
		for (String string : list1) {
			//1. 判断可以省略   省代码
			//2. 强转可以省略   省代码的同时还可以减少异常的产生
			System.out.println(string.length());
			
		}
		
		
	}
	
	
		
	
}

```

## 自定义泛型

```java
package com.atguigu.demo;

import java.util.ArrayList;
import java.util.HashMap;

/**
 * 此类用于演示  自定义泛型
 * 	1. 自定义泛型类
 * 		a.自己创建一个普通类
 * 			class Student{}
 * 	    b.在此类名的后面加符号<X> [括号内随意定义一个字母表示的泛型，建议是大写]  
 * 		c.在此类中就可以使用该泛型
 * 			属性类型
 * 			参数类型
 * 			返回值类型
 * 		Ps:静态资源不能用泛型   例：private static X score;
 * 		   不能够开辟空间    例：private X[] xs=new X[5];
 * 
 *  	在一个类中只能定义一个泛型？不是只有一个，可以是n个![除非不得已才定义多个]
 *  
 *    使用该泛型类：
 *    	和集合的泛型使用方式一致！
 *      如果泛型类存在继承关系？泛型该何去何从？
 *      	a. 可以在子类继承父类时指定
 *      		例：class Sub extends Student<String>{//作为Student类的子类
 *  		b. 子类在继承父类时，不能确定泛型的类型时
 *  			子类讲泛型继承下来，在实例化子类对象的时候指定
 *  			例：class Sub<X> extends Student<X>{
 *  		c.class Sub<X,T> extends Student<X,String> implements MyIter<T>{
 *  		D.Sub sub=new Sub(); 不指定泛型就默认Object.
 *  		
 *  2. 自定义泛型接口
 *  	定义方式和使用方式和自定义泛型类大体一致！
 *  		由于属性默认是静态常量，所以不能再属性位置使用泛型
 *  3. 自定义泛型方法[是在方法上声明泛型]
 *  	何时使用：想要使用的泛型范围只仅限于此方法
 *  	a. 创建一个方法
 *  		public void function(){
		
			}
		b. 在此方法修饰符后加<H>
		public<H> H function(X x,H h){//泛型H只能在此方法上使用    范围缩小了
		return h;
		}
		
		何时指定泛型的类型？调用此方法时！
		   是通过数据直接指定，
		   例：Double function = sub.function("java", 20.5);
 *  
 *  如果工作中遇到了自己没学过的内容？怎么办？
 *  	百度
 *  	查看人家是怎么写的，照猫画虎，[肯定会出问题，在找其他资源]
 *  注解的使用  --->  自定义注解
 *  异常的使用  --->  自定义异常
 *  泛型发使用  --->  自定义泛型
 * 
 *
 */
public class Demo2 {
	public static void main(String[] args) {
		Student<Double> stu=new Student<>(1,"张三",68.7);//没用泛型--不定义就是Object
		System.out.println("语文老师给的成绩："+stu.getScore());
		
		Student<String> stu2=new Student<>(1, "张三", "优");
		System.out.println("体育老师给的成绩:"+stu2.getScore());
		
		Sub<String,Double> sub=new Sub<>();
		Double function = sub.function("java", 20.5);
	}
}
/**
 * 自定义泛型的学生类
 * 需求：语文老师对学生成绩的要求是double类型   98   97.5   60   
 * 	        体育老师对学生成绩的要求是String     优     良   差 
 * 		英语老师对学生成绩的要求是int        1   2    3
 * 		...
 * 
 *  泛型就可以解决这个问题
 *  自定义泛型类已创建完成，何时确定score的类型呢？自定义反省类的使用[和上午讲的泛型使用一致]
 */
interface MyIter<T>{
//	T t;//不能作为属性(接口中的属性都是静态常量)
	public T method(T t);
}
//子类在继承父类时，不能确定泛型的类型
class Sub<X,T> extends Student<X> implements MyIter<T>{

	@Override
	public T method(T t) {
		return null;
	}
	public<H> H function(X x,H h){//泛型H只能在此方法上使用    范围缩小了
		return h;
	}
	
	
//	public void function1(X x,H h){
//		
//	}
	
}
class Student<X>{
	private int id;			//学号
	private String name;	//姓名
	private X score;	//成绩    泛型作为了属性的类型
	
	public Student() {
		super();
		// TODO Auto-generated constructor stub
	}
	public Student(int id, String name, X score) {//泛型作为参数类型
		super();
		this.id = id;
		this.name = name;
		this.score = score;
	}
	public int getId() {
		return id;
	}
	public void setId(int id) {
		this.id = id;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public X getScore() {//泛型作为方法的返回值类型了
		return score;
	}
	public void setScore(X score) {//泛型为参数类型
		this.score = score;
	}
	@Override
	public String toString() {
		return "Student [id=" + id + ", name=" + name + ", score=" + score + "]";
	}
	
	
}
```

##  类型变量的上限和泛型方法的应用

```java
package com.atguigu.demo;

import java.util.Arrays;

/**
 * 此类用于演示   类型变量的上限和泛型方法的应用
 *1. 类型变量的上限    为何要有这个技术！
 *	例：class Per<E extends Animal>{}   
 *		实例化Per对象时指定的泛型类型的上限是Animal[Animal及其以下都行]
 *2. 泛型方法的应用[作为工具类中的方法]
 *	需求:编写一个工具类中有一个方法实现对对象数组的排序[排除基本数据类型的数组]
 *		实现对对象数组的排序
		public<T extends Comparable<T>> void sort(T[] ts){//要求T[]中的内容必须实现Comparable这个接口
			//冒泡
			for (int i = 0; i < ts.length -1; i++) {
				for (int j = 0; j < ts.length -1 -i; j++) {
					if(ts[j].compareTo(ts[j+1])>0){
						T temp=ts[j];
						ts[j]=ts[j+1];
						ts[j+1]=temp;
					}
				}
			}
		}
 */
public class Demo3 {

	public static void main(String[] args) {
		Per<Dog> per=new Per<>(1,"",new Dog());
		Dog pet = per.getPet();
		Per<Cat> per1=new Per<>(1,"",new Cat());
		per.getPet();
		Per<Animal> per3=new Per<>(1,"",new Animal());
		per.getPet();
		
//		Per<String> per2=new Per<>(1,"","");
//		per.getPet();
		//① 判断② 强转
		Integer[] arrs={2,5,-5,67,12};
		Per[] pers={new Per(1, "", new Dog()),new Per(4, "", new Dog()),new Per(3, "", new Dog())};
		new ArrayUtil().sort(pers);//为什么报错？没实现接口
		
		System.out.println(Arrays.toString(pers));
		
	}
}
class ArrayUtil{
//	实现对对象数组的排序
	public<T extends Comparable<T>> void sort(T[] ts){//要求T[]中的内容必须实现Comparable这个接口
		//冒泡
		for (int i = 0; i < ts.length -1; i++) {
			for (int j = 0; j < ts.length -1 -i; j++) {
				if(ts[j].compareTo(ts[j+1])>0){
					T temp=ts[j];
					ts[j]=ts[j+1];
					ts[j+1]=temp;
				}
			}
		}
	}
}
class Per<E extends Animal> implements Comparable<Per>{//设置为泛型类
	private int id;			//编号
	private String name;	//姓名
	private E pet;			//宠物
	public Per(int id, String name, E pet) {
		super();
		this.id = id;
		this.name = name;
		this.pet = pet;
	}
	public int getId() {
		return id;
	}
	public void setId(int id) {
		this.id = id;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public E getPet() {
		return pet;
	}
	public void setPet(E pet) {
		this.pet = pet;
	}
	@Override
	public String toString() {
		return "Per [id=" + id + ", name=" + name + ", pet=" + pet + "]";
	}
	@Override
	public int compareTo(Per o) {
		// TODO Auto-generated method stub
		return this.id-o.id;
	}
	
	
}
```

## 通配符

```java
package com.atguigu.demo;

import java.util.ArrayList;
import java.util.List;

/**
 * 此类用于演示  通配符
 *	当我们声明一个方法时，某个形参的类型是一个参数化的泛型类或泛型接口类型，
 *	但是在声明方法时，又不确定该泛型实际类型，我们可以考虑使用类型通配符。
 *
 *	<?>  匹配所有类型
 *  
 *
 */
public class Demo4 {
	public static void main(String[] args) {
		List<Animal> list=new ArrayList<>();
		test1(list);//报错原因，就是人家要泛型为String类型的集合
		//要求:集合中的数据必须是某个家族中的内容   Animal->Dog/Cat
		/*如果是任意类型  
		 * a. 直接不指定
		 * b. 用<?>代替    
		 *如果是指定上限：
		 *	  <? extends 上限类型>
		 *如果是指定下限：
		 *	  <? super 下限类型>
		 *
		 *使用类型通配符来指定类型参数的问题:
		 *	  不太理解  
		 */
			
	}
	
	public static void test1(List<? super Animal> list){
		//对该集合进行遍历是没任何问题的！但是如果想新增数据？
		list.add(null);//局限性很大了
		list.add(null);//确定不了集合的泛型类型只能添加null
		list.add(new Dog());//因为list集合的类型最低为Animal
		
	}
}
```

