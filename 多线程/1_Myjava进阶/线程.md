# 线程

##  并发与并行（了解）

* **并行**（parallel）：指两个或多个事件在**同一时刻**发生（同时发生）。指在同一时刻，有多条指令在多个处理器上同时执行。
* **并发**（concurrency）：指两个或多个事件在**同一个时间段内**发生。指在同一个时刻只能有一条指令执行，但多个进程的指令被快速轮换执行，使得在宏观上具有多个进程同时执行的效果。

![](C:/Users/28331/Desktop/笔记版/尚硅谷_Java核心编程_第17章_多线程/imgs/并行与并发.bmp)

在操作系统中，安装了多个程序，并发指的是在一段时间内宏观上有多个程序同时运行，这在单 CPU 系统中，每一时刻只能有一个程序执行，即微观上这些程序是分时的交替运行，只不过是给人的感觉是同时运行，那是因为分时交替运行的时间是非常短的。

而在多个 CPU 系统中，则这些可以并发执行的程序便可以分配到多个处理器上（CPU），实现多任务并行执行，即利用每个处理器来处理一个可以并发执行的程序，这样多个程序便可以同时执行。目前电脑市场上说的多核 CPU，便是多核处理器，核越多，**并行**处理的程序越多，能大大的提高电脑运行的效率。

> 注意：**单核**处理器的计算机肯定是**不能并行**的处理多个任务的，只能是多个任务在单个CPU上并发运行。同理，线程也是一样的，从宏观角度上理解线程是并行运行的，但是从微观角度上分析却是串行运行的，即一个线程一个线程的去运行，当系统只有一个CPU时，线程会以某种顺序执行多个线程，我们把这种情况称之为线程调度。

## 线程与进程

* **程序**：为了完成某个任务和功能，选择一种编程语言编写的一组指令的集合。

* **软件**：**1个或多个**应用程序+相关的素材和资源文件等构成一个软件系统。

* **进程**：是指一个内存中运行的应用程序，每个进程都有一个独立的内存空间，进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。

* **线程**：线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。 

  简而言之：一个软件中至少有一个应用程序，应用程序的一次运行就是一个进程，一个进程中至少有一个线程。

* 面试题：进程是操作系统调度和分配资源的最小单位，线程是CPU调度的最小单位。不同的进程之间是不共享内存的。进程之间的数据交换和通信的成本是很高。不同的线程是共享同一个进程的内存的。当然不同的线程也有自己独立的内存空间。对于方法区，堆中中的同一个对象的内存，线程之间是可以共享的，但是栈的局部变量永远是独立的。

例如：

#### 一个软件中包含多个进程

![1563267154695](C:/Users/28331/Desktop/笔记版/尚硅谷_Java核心编程_第17章_多线程/imgs/1563267154695.png)

#### 每个应用程序的运行都是一个进程

我们可以再电脑底部任务栏，右键----->打开任务管理器,可以查看当前任务的进程：

![](C:/Users/28331/Desktop/笔记版/尚硅谷_Java核心编程_第17章_多线程/imgs/进程概念.png)

#### 一个应用程序的多次运行，就是多个进程

![1563267431480](C:/Users/28331/Desktop/笔记版/尚硅谷_Java核心编程_第17章_多线程/imgs/1563267431480.png)

#### 一个进程中包含多个线程

![1563270525077](C:/Users/28331/Desktop/笔记版/尚硅谷_Java核心编程_第17章_多线程/imgs/1563270525077.png)

## 线程调度

- 分时调度

  所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。

- 抢占式调度

  优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)，Java使用的为抢占式调度。

  - 抢占式调度详解

    大部分操作系统都支持多进程并发运行，现在的操作系统几乎都支持同时运行多个程序。比如：现在我们上课一边使用编辑器，一边使用录屏软件，同时还开着画图板，dos窗口等软件。此时，这些程序是在同时运行，”感觉这些软件好像在同一时刻运行着“。

    实际上，CPU(中央处理器)使用抢占式调度模式在多个线程间进行着高速的切换。对于CPU的一个核而言，某个时刻，只能执行一个线程，而 CPU的在多个线程间切换速度相对我们的感觉要快，看上去就是在同一时刻运行。
    其实，多线程程序并不能提高程序的运行速度，但能够提高程序运行效率，让CPU的使用率更高。

    ![抢占式调度](C:/Users/28331/Desktop/笔记版/尚硅谷_Java核心编程_第17章_多线程/imgs/抢占式调度.bmp)

##  另行创建和启动线程

当运行Java程序时，其实已经有一个线程了，那就是main线程。

![1563281796505](C:/Users/28331/Desktop/笔记版/尚硅谷_Java核心编程_第17章_多线程/imgs/1563281796505.png)

那么如何创建和启动main线程以外的线程呢？

## 创建线程的两种方式（重点！！！！！！）

###  继承Thread类

Java使用`java.lang.Thread`类代表**线程**，所有的线程对象都必须是Thread类或其子类的实例。每个线程的作用是完成一定的任务，实际上就是执行一段程序流即一段顺序执行的代码。Java使用线程执行体来代表这段程序流。Java中通过继承Thread类来**创建**并**启动多线程**的步骤如下：

1. 定义Thread类的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务,因此把run()方法称为线程执行体。
2. 创建Thread子类的实例，即创建了线程对象
3. 调用线程对象的start()方法来启动该线程

###  实现Runnable接口

Java有单继承的限制，当我们无法继承Thread类时，那么该如何做呢？在核心类库中提供了Runnable接口，我们可以实现Runnable接口，重写run()方法，然后再通过Thread类的对象代理启动和执行我们的线程体run()方法

步骤如下：

1. 定义Runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。
2. 创建Runnable实现类的实例，并以此实例作为Thread的target来创建Thread对象，该Thread对象才是真正
   的线程对象。
3. 调用线程对象的start()方法来启动线程。

###  实现Runnable接口方式和继承Thread类方式有什么区别？

 * 	   a. 采用实现接口的方式，可以避免java的单继承
 * 	   b. 实现接口的方式比较方便操作共享资源
 * 	   c. 

```java
public class Demo1 {

	public static void main(String[] args) {
		//运行时，会启动几个线程   main(主线程) 垃圾回收(GC) 
		//创建一个子线程运行     (3个线程在运行，主线程，子线程，垃圾回收：忽略)
		//主线程和子线程必须要并发发可以？
		//想要的是test中的循环和main方法中的循环并发执行
//		必须将test中的循环放在一个子线程中
		//顺序结构     由上到下
		
		ThreadDemo1 threadDemo1=new ThreadDemo1();
//		threadDemo1.run();//这是启动子线程？？   这个依然是方法的调用，依然时单线程
		//
		Thread t1=new Thread(threadDemo1);//多态的知识点(向上转型)
		t1.start();//才是启动子线程的方法(虽然我调用的是start方法，但是真正执行的依然是run方法中的代码)
		
		
		//启动继承方式的子线程
		ThreadDemo2 threadDemo2 =new ThreadDemo2(); 
		threadDemo2.start();
		
		for (int i = 0; i < 100; i++) {
			try {
				Thread.sleep(5000);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			System.out.println("main-----"+i);
		}
		
	}
}
class ThreadDemo2 extends Thread{
	public ThreadDemo2(){
		super();//调用Thread无参构造器
	}
	@Override
	public void run() {
		//该线程需要运行的代码
		try {
			Thread.sleep(5000);
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		for (int i = 0; i < 100; i++) {
			System.out.println("ThreadDemo2----"+i);
		}
	}
	
}

class ThreadDemo1 implements Runnable{

	@Override
	public void run() {//就是子线程运行的方法
		try {
			Thread.sleep(5000);
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		for (int i = 0; i < 100; i++) {
			System.out.println("ThreadDemo1-----"+i);
		}
	}
}
```

### 使用匿名内部类对象来实现线程的创建和启动

```java
package com.atguigu.Thread;
/**
 * 此类用于演示  匿名内部类创建和启动线程(了解)
 *	a. 接口的形式
 *		new Thread(new Runnable() {
			@Override
			public void run() {
				for (int i = 0; i < 100; i++) {
					System.out.println("匿名内部类的线程床和启动--"+i);
				}
			}
		}).start();
	b. 继承的形式
		new Thread(){
			@Override
			public void run() {
				for (int i = 0; i < 100; i++) {
					System.out.println("匿名内部类的继承方式--"+i);
				}
			}
		}.start();
 */
public class Demo2 {

	public static void main(String[] args) {
		new Thread(new Runnable() {
			@Override
			public void run() {
				for (int i = 0; i < 100; i++) {
					System.out.println("匿名内部类的线程创建和启动--"+i);
				}
			}
		}).start();
		
		new Thread(){
			@Override
			public void run() {
				for (int i = 0; i < 100; i++) {
					System.out.println("匿名内部类的继承方式--"+i);
				}
			}
		}.start();
		
		
		for (int i = 0; i < 100; i++) {
			System.out.println("main---"+i);
		}
	}
}
```

## Thread类

public Thread() :分配一个新的线程对象。
public Thread(String name) :分配一个指定名字的新的线程对象。
public Thread(Runnable target) :分配一个带有指定目标新的线程对象。
public Thread(Runnable target,String name) :分配一个带有指定目标新的线程对象并指定名字。

**My:new  Thread()相当于是开辟了一个新栈，并且把run方法压入栈（就比如main()方法），如果传入一个Runnable target，则把传入的对象的.run ()方法压入栈，如果是继承就把继承重写的run()方法压入栈。通过start的方法启动子线程（创建的线程）。**

###  常用方法系列1

* public void run() :此线程要执行的任务在此处定义代码。
* public String getName() :获取当前线程名称。
* public static Thread currentThread() :返回对当前正在执行的线程对象的引用。
* public final boolean isAlive()：测试线程是否处于活动状态。如果线程已经启动且尚未终止，则为活动状态。 
* public final int getPriority() ：返回线程优先级 
* public final void setPriority(int newPriority) ：改变线程的优先级
* main方法默认优先级是5
  * 每个线程都有一定的优先级，优先级高的线程将获得较多的执行机会。每个线程默认的优先级都与创建它的父线程具有相同的优先级。Thread类提供了setPriority(int newPriority)和getPriority()方法类设置和获取线程的优先级，其中setPriority方法需要一个整数，并且范围在[1,10]之间，通常推荐设置Thread类的三个优先级常量：
  * MAX_PRIORITY（10）：最高优先级 
  * MIN _PRIORITY （1）：最低优先级
  * NORM_PRIORITY （5）：普通优先级，默认情况下main线程具有普通优先级。

### 常用方法系列2

* public void start() :导致此线程开始执行; Java虚拟机调用此线程的run方法。

* public static void sleep(long millis) :使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。（My：与谁调用这个方法没关系，那个线程执行这个方法，那个线程就睡眠。

* MY：sleep()使当前线程进入停滞状态（阻塞当前线程），让出CUP的使用、目的是不让当前线程独自霸占该进程所获的CPU资源，以留一定时间给其他线程执行的机会。所以不会占用cpu。）

* public static void yield()：yield只是让当前线程暂停一下，让系统的线程调度器重新调度一次，希望优先级与当前线程相同或更高的其他线程能够获得执行机会，但是这个不能保证，完全有可能的情况是，当某个线程调用了yield方法暂停之后，线程调度器又将其调度出来重新执行。

  ```java
  package com.atguigu.Thread;
  /**
   * 此类用于演示yield方法效果
   *
   */
  public class YieldDemo {
  
  	public static void main(String[] args) {
  		
  		//启动子线程
  		Thread101 t1=new Thread101();
  		t1.start();
  		
  		for (int i = 0; i < 100000; i++) {
  			String str=new String("hello"+i);
  			str+="aaaa"+i;
  		}
  	}
  }
  class Thread101 extends Thread{
      
  	@Override
  	public void run() {
  		long start=System.currentTimeMillis();
  		for (int i = 0; i < 100000; i++) {
  			String str=new String("hello"+i);
  			str+="aaaa"+i;
  			Thread.yield();//循环一次就让步一次
  		}
  		long end=System.currentTimeMillis();
  		System.out.println("执行时间："+(end-start));
  	}
  	
  }
  
  ```

  

* void join() ：等待该线程终止。 

  void join(long millis) ：等待该线程终止的时间最长为 millis 毫秒。如果millis时间到，将不再等待。 

  void join(long millis, int nanos) ：等待该线程终止的时间最长为 millis 毫秒 + nanos 纳秒。 

  ```java
  package com.atguigu.Thread;
  /**
   * 此类用于演示join方法
   *
   */
  public class JoinDemo {
  
  	public static void main(String[] args) {
  		
  		Thread102 t2=new Thread102();
  		t2.start();
  		
  		for (int i = 0; i < 10; i++) {
  			try {
  				if(i==5){
  //					t2.join(2000);//t2调用join方法
  					//谁插队(调用join方法线程插队)？   t2
  					//谁等待(哪个线程执行join方法，哪个等待)？  main
  					//i==5时，让t2结束
  					//t2.stop();
  //					使用变量的值的变化来控制线程的结束
  					t2.setFlag(true);
  				}
  				Thread.sleep(500);
  			} catch (InterruptedException e) {
  				e.printStackTrace();
  			}
  			System.out.println("main---"+i);
  		}
  	}
  }
  class Thread102 extends Thread{
  	private boolean flag=false;
      
  	@Override
  	public void run() {
  		for (int i = 0; i < 10; i++) {
  			try {
  				Thread.sleep(500);
  			} catch (InterruptedException e) {
  				e.printStackTrace();
  			}
  			System.out.println("Thread102---"+i);
  			if(flag){
  				return;//让run方法结束
  			}
  		}
  	}
  
  	public boolean isFlag() {
  		return flag;
  	}
  
  	public void setFlag(boolean flag) {
  		this.flag = flag;
  	}
  	
  }
  ```

  

* public final void stop()：强迫线程停止执行。 该方法具有固有的不安全性，已经标记为@Deprecated不建议再使用，那么我们就需要通过其他方式来停止线程了，其中一种方式是使用变量的值的变化来控制线程是否结束。

  ### 示例代码

  ```java
  package com.atguigu.Thread;
  /**
   * 此类用于演示  Thread类
   * 1. 构造器：
   * 		public Thread() :分配一个新的线程对象。其子类调用
   * 		public Thread(String name);分配一个指定名字的新的线程对象
   * 				线程的名字不是我们关注的重点
   * 		public Thread(Runnable target) :分配一个带有指定目标新的线程对象。
   * 		public Thread(Runnable target,String name) :分配一个带有指定目标新的线程对象。
   * 
   * 2. 常用方法：
   * 		常用方法系列一
   * 			public void run() :此线程要执行的任务在此处定义代码。
   *			public String getName() :获取当前线程名称。
   *			public static Thread currentThread() :返回对当前正在执行的线程对象的引用。
   			public final boolean isAlive()：测试线程是否处于活动状态。如果线程已经启动且尚未终止，则为活动状态。
   				线程结束的标识：
   					run方法执行完毕(代码运行完毕，遇到return...)
   					stop方法
   			public final int getPriority() ：返回线程优先级 
   				每个线程都有一定的优先级，线程的优先级分为10个等级[1-10]的整数  10是最高  1最低
   				Thread对于优先级提供了三个常量，MIN_PRIORITY(1) NORM_PRIORITY(5) MAX_PRIORITY(10)
   				线程的初始优先级和创建该线程的线程优先级保持一致
   					main方法默认优先级是5，t1的优先级是多少
   			public final void setPriority(int newPriority) ：改变线程的优先级
   			
   		常用方法系列二
   			public void start() :导致此线程开始执行; Java虚拟机调用此线程的run方法。
   			public static void sleep(long millis) :使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。
   			public static void yield()：线程的让步
   				yield只是让当前线程暂停一下，让系统的线程调度器重新调度一次，
   				希望优先级与当前线程相同或更高的其他线程能够获得执行机会，
   				  总结：当线程抢到执行权了，让出该执行权,和其他线程在重新抢执行权力，
   				  	     还是有可能被自己抢到的
   				演示效果(效果不明显)
   			void join() ：线程的插队
   			void join(long millis) ：设置插队的时间
   			void join(long millis, int nanos) ：
   				谁插队？(调用join方法线程插队)？
   				谁等待？(哪个线程执行join方法，哪个等待)？
   			public final void stop()：强迫线程停止执行(不建议大家使用)
   				建议大家使用结束run方法的方式
   */
  public class Demo3 {
  	
  
  	public static void main(String[] args) {
  		Thread.currentThread().setPriority(Thread.MAX_PRIORITY);
  		/*Thread t=new Thread();
  		t.start();*/
  		Thread1 t1=new Thread1("尚硅谷");//自己制定线程的名字
  		//t1相当于是线程的引用
  		System.out.println(t1.getName());//获取线程的名字 默认(Thread-n)
  		
  		System.out.println("主线程的优先级为----"+Thread.currentThread().getPriority());//6
  		System.out.println("t1的优先级为----"+t1.getPriority());// 6 5
  		t1.start();
  		
  		//查看主线程的线程名字？   有线程的引用吗？
  		Thread abc = Thread.currentThread();
  //		返回对当前正在执行的线程对象的引用。(此方法运行在哪个线程中就获取哪个线程的引用)
  		System.out.println(abc.getName());
  		for (int i = 0; i < 10; i++) {
  			if(i==6){//t1大概率运行完毕
  				System.out.println("t1是否存活----"+t1.isAlive());//true
  			}
  			try {
  				Thread.sleep(500);
  			} catch (InterruptedException e) {
  				e.printStackTrace();
  			}
  			System.out.println(i);
  		}
  	}
  }
  
  class Thread1 extends Thread{
  	public Thread1(String name){
  		super(name);//调用Thread类中有参构造(参数为String)
  	}
  	public Thread1(){
  	}
  	@Override
  	public void run() {
  		for (int i = 0; i < 5; i++) {
  //			Thread.currentThread()运行在t1线程内，
  			try {
  				Thread.sleep(500);
  			} catch (InterruptedException e) {
  				e.printStackTrace();
  			}
  			System.out.println(Thread.currentThread().getName()+i);
  		}
  	}
  	
  }
  ```

  ### 线程安全
  
  ```java
  package com.atguigu.Thread;
  /**
   * 需求：
   * 	模拟一个售票系统！有三个售票窗口！一趟列车的总票数是100张！
   * 		提示：三个售票窗口就是三个线程，各个都是1秒钟卖一张票
   *   窗口A卖出了一张票，剩余99张！
   *   窗口B卖出了一张票，剩余98张！
   *   窗口C卖出了一张票，剩余97张！
   *   窗口C卖出了一张票，剩余96张！
   *   窗口A卖出了一张票，剩余95张！
   *   窗口B卖出了一张票，剩余94张！
   *   ...
   *   
   *如何解决线程安全问题？
   *	1. 出现多个窗口卖同一张票(错误，不允许出现的情况)
   *	2. 还出现了负票的情况
   *
   *上锁：***
   *	a:同步代码块
   *		synchronized(锁对象){需要上同步锁的代码}
   *			锁对象：任意对象(三个线程必须是同一个对象)  ***
  	 			继承Thread类创建的线程，锁对象一般用   类名.class
  	 			实现Runnable接口创建的线程，锁对象一般同  this
   *	b：
   *		
   *	c：
   *
   *
   *练习：
   *	1. 尝试用两种方式实现售票需求！
   *  2. 采用同步代码块去解决线程安全问题！
   */
  public class Demo4 {
  
  	public static void main(String[] args) {
  		//创建三个线程    存在什么问题？各自都是100张票    
  //		依然存在问题：线程不安全(暂时先不解决)
  		//继承Thread的方式：需要将num进行static
  		Thread201 t1=new Thread201("窗口A");
  		t1.start();
  		Thread201 t2=new Thread201("窗口B");
  		t2.start();
  		Thread201 t3=new Thread201("窗口C");
  		t3.start();
  		//实现接口的方式    并发执行(多核处理器是有可能存在并行执行的)
  		
  		/*Thread202 t=new Thread202();
  //		依然存在问题：线程不安全(暂时先不解决)
  		//包装
  		Thread t1=new Thread(t, "窗口A");
  		t1.start();
  		
  		Thread t2=new Thread(t, "窗口B");
  		t2.start();
  		
  		Thread t3=new Thread(t, "窗口C");
  		t3.start();*/
  		
  		
  //		Thread202 t=new Thread202();//是否有必要在重新new一个？没必要，只需要包装三次就可以了
  		
  		
  	}
  }
  class Thread202 implements Runnable{
  	private int num=100;//是够有必要将num进行静态化？？？
  	@Override
  	public void run() {
  		while(true){
  			//给整体上一把锁   锁对象：任意对象(三个线程必须是同一个对象)
  			synchronized(this){//this当前对象  --> t
  				try {
  					Thread.sleep(10);
  				} catch (InterruptedException e) {
  					e.printStackTrace();
  				}
  				//循环什么结束？当票数小于等于0
  				if(num<=0){
  					System.out.println("票卖完了");
  					return ;//break;
  				}
  				System.out.println(Thread.currentThread().getName()+"卖出了一张票，剩余"+--num);
  			}
  		}
  	}
  	
  }
  class Thread201 extends Thread{
  	public Thread201(String name){
  		super(name);
  	}
  	private static int num=100;//普通的属性(属于对象)   --->   静态属性(属于类的)
  	//静态常量如果过多是一件好事还是一件坏事？？？   坏事(不建议什么做)
  	@Override
  	public void run() {
  		while(true){
  			synchronized (Thread201.class) {//用this是否可以？因为不是同一个
  				try {
  					Thread.sleep(10);
  				} catch (InterruptedException e) {
  					e.printStackTrace();
  				}
  				//循环什么结束？当票数小于等于0
  				if(num<=0){
  					System.out.println("票卖完了");
  					return ;//break;
  				}
  				System.out.println(Thread.currentThread().getName()+"卖出了一张票，剩余"+--num);
  			}
  		}
  	}
  }
  ```
  
  发现程序出现了两个问题：
  
  1. 相同的票数,比如某张票被卖了两回。
  2. 不存在的票，比如0票与-1票，是不存在的。
  
  这种问题，几个窗口(线程)票数不同步了，这种问题称为线程不安全。
  
  当我们使用多个线程访问**同一资源**（可以是同一个变量、同一个文件、同一条记录等）的时候，若多个线程只有读操作，那么不会发生线程安全问题，但是如果多个线程中对资源有读和写的操作，就容易出现线程安全问题。
  要解决上述多线程并发访问一个资源的安全性问题:也就是解决重复票与不存在票问题，Java中提供了同步机制
  (synchronized)来解决。
  
  ![1563372934332](C:/Users/28331/Desktop/笔记版/尚硅谷_Java核心编程_第17章_多线程/imgs/1563372934332.png)
  
  根据案例简述：
  
  **窗口1线程进入操作的时候，窗口2和窗口3线程只能在外等着，窗口1操作结束，窗口1和窗口2和窗口3才有机会进入代码去执行。**也就是说在某个线程修改共享资源的时候，其他线程不能修改该资源，等待修改完毕同步之后，才能去抢夺CPU资源，完成对应的操作，保证了数据的同步性，解决了线程不安全的现象。
  
  为了保证每个线程都能正常执行原子操作,Java引入了线程同步机制。
  那么怎么去使用呢？有三种方式完成同步操作：
  
  1. 同步代码块。
  2. 同步方法。
  3. 锁机制
  
  ### 同步代码块
  
  * 同步代码块： synchronized 关键字可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。
    格式:
  
    ```java
    synchronized(同步锁){
         需要同步操作的代码
    }
    ```
  
    * 同步锁:
      对象的同步锁只是一个概念,可以想象为在对象上标记了一个锁.
  
    ​	锁对象 可以是任意类型。
  
    ​	多个线程对象  要使用同一把锁。
    注意:**在任何时候,最多允许一个线程拥有同步锁,谁拿到锁就进入代码块,其他的线程只能在外等着**(BLOCKED)。

### **my1(更多针对同步代码块)**  

### **来源于百度**（https://baike.baidu.com/item/synchronized/8483356?fr=aladdin）

synchronized [关键字]()，代表这个方法加锁,相当于不管哪一个线程（例如线程A），运行到这个方法时,都要检查有没有其它线程B（或者C、 D等）正在用这个方法(**或者该类的其他同步方法**)，有的话要等正在使用synchronized方法的线程B（或者C 、D）运行完这个方法后再运行此线程A,没有的话,锁定调用者,然后直接运行。它包括两种用法：synchronized 方法和 synchronized 块。（**my:这是针对同一个类实例对象，这时候他们的锁方法对象是同一个this---synchronized(this)**）

Java语言的关键字，可用来给对象和方法或者代码块加锁，当它锁定一个方法或者一个代码块的时候，同一时刻最多只有一个线程执行这段代码。当两个并发线程访问同一个对象object中的这个加锁同步代码块时，一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。**然而，当一个线程访问object的一个加锁代码块时，另一个线程仍可以访问该object中的非加锁代码块。**

## synchronized理解

[编辑](javascript:;)

一、当两个并发线程访问同一个对象object中的这个synchronized(this)同步代码块时，一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。

二、然而，

块。

三、尤其关键的是，当一个线程访问object的一个synchronized(this)同步代码块时，其他线程对object中所有其它synchronized(this)同步代码块的访问将被阻塞。

四、第三个例子同样适用其它同步代码块，它就获得了这个object的对象锁。结果，其它线程对该object对象所有同步代码部分的访问都被暂时阻塞。

五、以上规则对其它对象锁同样适用。

```java
package com.java.day27.work;

public class MyD2 {

	public static void main(String[] args) {
		T1 t1 = new T1("大娃");
		T1 t2 = new T1("小娃");
		t1.start();
		t2.start();
	}

}
class T1 extends Thread{
	public T1(String name) {
		super(name);
	}
	private static int num=0;
	@Override
	public void run() {
		synchronized (this.getClass()) {
			for(int i=0;i<10;i++) {
				try {
					sleep(500);
				} catch (InterruptedException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
				System.out.println(getName()+"num="+(num+=i)+"i="+i);
			}
		}
		for (int i = 0; i <20; i++) {
			try {
				sleep(500);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			System.out.println("==========="+getName()+"num="+(num+=i)+"i="+i);
		}
	}
}
```

| 运行结果（当小娃运行到锁代码块的时候，其大娃的不是同一个锁对象的代码仍然可以和小娃抢CPU） |
| ------------------------------------------------------------ |
| 大娃num=0i=0<br/>大娃num=1i=1<br/>大娃num=3i=2<br/>大娃num=6i=3<br/>大娃num=10i=4<br/>大娃num=15i=5<br/>大娃num=21i=6<br/>大娃num=28i=7<br/>大娃num=36i=8<br/>大娃num=45i=9<br/>===========大娃num=45i=0<br/>小娃num=45i=0<br/>===========大娃num=47i=1<br/>小娃num=46i=1<br/>小娃num=49i=2<br/>===========大娃num=51i=2<br/>小娃num=54i=3<br/>===========大娃num=57i=3<br/>===========大娃num=61i=4<br/>小娃num=65i=4<br/>小娃num=70i=5<br/>===========大娃num=75i=5<br/>小娃num=81i=6<br/>===========大娃num=87i=6<br/>===========大娃num=94i=7<br/>小娃num=101i=7<br/>===========大娃num=109i=8<br/>小娃num=117i=8<br/>===========大娃num=126i=9<br/>小娃num=135i=9<br/>===========大娃num=145i=10<br/>===========小娃num=135i=0<br/>===========大娃num=156i=11<br/>===========小娃num=157i=1<br/>===========大娃num=169i=12<br/>===========小娃num=171i=2<br/>===========大娃num=184i=13<br/>===========小娃num=187i=3<br/>===========大娃num=201i=14<br/>===========小娃num=205i=4<br/>===========大娃num=220i=15<br/>===========小娃num=225i=5<br/>===========大娃num=241i=16<br/>===========小娃num=247i=6<br/>===========小娃num=254i=7<br/>===========大娃num=271i=17<br/>===========小娃num=279i=8<br/>===========大娃num=297i=18<br/>===========大娃num=316i=19<br/>===========小娃num=325i=9<br/>===========小娃num=335i=10<br/>===========小娃num=346i=11<br/>===========小娃num=358i=12<br/>===========小娃num=371i=13<br/>===========小娃num=385i=14<br/>===========小娃num=400i=15<br/>===========小娃num=416i=16<br/>===========小娃num=433i=17<br/>===========小娃num=451i=18<br/>===========小娃num=470i=19 |

### **my2(更多针对锁方法)**

### ------来源于搜狗（https://baike.sogou.com/v7893079.htm?fromTitle=synchronized）

## 基本概述

[编辑](https://baike.sogou.com/Create.e?sp=2&sp=l7893079&sp=1)

synchronized关键字，代表这个方法加锁,相当于不管哪一个线程（例如线程A），运行到这个方法时,都要检查有没有其它线程B（或者C、D等）正在用这个方法，有的话要等正在使用synchronized方法的线程B（或者C、D）运行完这个方法后再运行此线程A,没有的话,直接运行。它包括两种用法：synchronized方法和synchronized块。

### synchronized 方法

声明是为了定义变量的作用范围和[作用域](https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=71121105&ss_c=ssc.citiao.link)

通过在方法声明中加入synchronized关键字来声明synchronized方法。如：

public synchronized void access Val(intnew Val);

synchronized方法控制对类成员变量的访问：**每个类实例对应一把锁**，每个synchronized方法都必须获得调用该方法的类实例的锁方能执行，否则所属[线程阻塞](https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=71644860&ss_c=ssc.citiao.link)，方法一旦执行，就独占该锁，直到从该方法返回时才将锁释放，此后被阻塞的线程方能获得该锁，重新进入可执行状态。这**种机制确保了同一时刻对于每一个类实例，其所有声明为synchronized的成员函数中至多只有一个处于可执行状态（因为至多只有一个能够获得该类实例对应的锁）**，从而有效避免了类成员变量的访问冲突（只要所有可能访问类成员变量的方法均被声明为synchronized）。（

class Thread1 implements Runnable{}）

```java
/* 采用实现接口方式的启动
		 * Thread1 t=new Thread1(account);
		
		Thread t1=new Thread(t);
		t1.start();
		Thread t2=new Thread(t);
		t2.start();*/
```

（下面两段更多是废话，不读也可以）

在Java中，不光是类实例，每一个类也对应一把锁，这样我们也可将类的静态成员[函数声明](https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=73743882&ss_c=ssc.citiao.link)为synchronized，以控制其对类的[静态成员变量](https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=397639&ss_c=ssc.citiao.link)的访问。

synchronized方法的缺陷：若将一个大的方法声明为synchronized将会大大影响效率，典型地，若将线程类的方法run()声明为synchronized，由于在线程的整个生命期内它一直在运行，因此将导致它对本类任何synchronized方法的调用都永远不会成功。当然我们可以通过将访问类成员变量的代码放到专门的方法中，将其声明为synchronized，并在主方法中调用来解决这一问题，但是Java为我们提供了更好的解决办法，那就是synchronized块。

```Java
package com.atguigu.ThreadDemo;
/**
 * 此类用于演示     同步方法
 * 	线程安全--->效率肯定低
 * a. 同步代码块
 * 	synchronized(锁对象[多个线程必须是同一个对象]){需要上锁的代码}
 * b. 同步方法
 * 	b.1 实现Runnable接口的方式  在普通方法的修饰符位置加上  synchronized
 * 		public synchronized boolean test1(){}
 *  b.2 继承Thread类的方式    在普通方法的修饰符位置加上 static synchronized
 *  	public static synchronized boolean test1(){}
 * c. Lock锁
 * 	c.1  实现Runnable接口的方式
 * 
 *  c.2 继承Thread类的方式
 * 
 * 
 * 
 * 同一个账户，两个储户去取钱
 */

public class Demo1 {

	public static void main(String[] args) {
		Account account=new Account(1001,10000);
		
		/* 采用实现接口方式的启动
		 * Thread1 t=new Thread1(account);
		
		Thread t1=new Thread(t);
		t1.start();
		Thread t2=new Thread(t);
		t2.start();*/
		/*
		 * 采用竭诚方式的启动
		 */
		Thread2 t1=new Thread2(account);
		t1.start();
		Thread2 t2=new Thread2(account);
		t2.start();
	}
}
//老师在试一下继承的方式有无问题
class Thread2 extends Thread{
	private static Account account;//需要设置为static
	public Thread2(Account account) {
		super();
		this.account = account;
	}
	@Override
	public void run() {
		while(true){
			//还是取钱的过程
			boolean test1 = test1();
			if(test1){
				return;
			}
		}
	}
	public static synchronized boolean test1(){//加上static，锁对象相当于换成了this.getClass()
		//一次完整的取钱经历    (只能有一个线程在运行)
		try {
			Thread.sleep(100);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		if(account.getMoney()<=0){
			System.out.println("没钱了。。。。");
			return true;//结束当前方法(run方法)--->结束当前线程
		}
		account.setMoney(account.getMoney()-100);
		System.out.println(Thread.currentThread().getName()+"取了100块，剩余"+account.getMoney());
		return false;
	}
	
}
class Thread1 implements Runnable{
	private Account account;

	public Thread1(Account account) {
		super();
		this.account = account;
	}

	@Override
	public void run() {
		while(true){
//			System.out.println("-----");//没有必要放在锁里面
			boolean test1 = test1();//取钱的过程
			if(test1){
				return;
			}
//			System.out.println("====");
		}
	}
	//是否存在锁对象？？  this
	//如果子线程是通过继承的方式创建的？能行吗？不行！我们去试一试
	public synchronized boolean test1(){
		//一次完整的取钱经历    (只能有一个线程在运行)
		try {
			Thread.sleep(100);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		if(account.getMoney()<=0){
			System.out.println("没钱了。。。。");
			return true;//结束当前方法(run方法)--->结束当前线程
		}
		account.setMoney(account.getMoney()-100);
		System.out.println(Thread.currentThread().getName()+"取了100块，剩余"+account.getMoney());
		return false;
	}
	
}
class Account{
	private int id;// 银行卡号
	private int money;//银行余额
	public Account(int id, int money) {
		super();
		this.id = id;
		this.money = money;
	}
	public int getId() {
		return id;
	}
	public void setId(int id) {
		this.id = id;
	}
	public int getMoney() {
		return money;
	}
	public void setMoney(int money) {
		this.money = money;
	}
	@Override
	public String toString() {
		return "Account [id=" + id + ", money=" + money + "]";
	}
	
	
}
```



### synchronized 块

通过synchronized关键字来声明synchronized块。语法如下：

synchronized(sync Object){

//允许访问控制的代码

}

synchronized块是这样一个代码块，其中的代码必须获得对象sync Object（如前所述，可以是类实例或类）的锁方能执行，具体机制同前所述。由于可以针对任意代码块，且可任意指定上锁的对象，故灵活性较高。

## *2*相关理解

[编辑](https://baike.sogou.com/Create.e?sp=2&sp=l7893079&sp=4)

一、当两个并发线程访问同一个[对象object](https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=175857778&ss_c=ssc.citiao.link)中的这个synchronized(this)同步代码块时，一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。

二、然而，另一个线程仍然可以访问该object中的非synchronized(this)同步代码块。

三、尤其关键的是，当一个线程访问object的一个synchronized(this)同步代码块时，其他线程对object中所有其它synchronized(this)同步代码块的访问将被阻塞。

四、第三个例子同样适用其它同步代码块，它就获得了这个object的对象锁。结果，其它线程对该object对象所有同步代码部分的访问都被暂时阻塞。

五、以上规则对其它对象锁同样适用.

### **my3:锁对象不分class类**，不分代码（不管是不是相同，只看是不是同一个锁对向）

```java
package com.atguigu.homework;
/**
 * 创建和启动2个子线程，一个打印1-10之间奇数，一个打印1-10之间偶数，
（1）要求每个线程要么不打印，要么就连续打印5个数，每个数打印间隔500毫秒
（2）但两个线程不要求交替打印。//不要求五五开
 *a. 线程---
 *b. 设计模式(单例模式-工厂模式-代理模式)   23种
 */
public class Home3 {

	public static void main(String[] args) {
		Thread101 t1=new Thread101();//先启动的有优势
		Thread102 t2=new Thread102();
		t1.start();
		t2.start();
	}
}
class Thread101 extends Thread{//奇数
	@Override
	public void run() {
		while(true){//多次打印 五个数
			synchronized ("java") {
			//含义就是一个线程必须将for循环全部执行完，另外的线程才能执行(同步锁)
			
				for (int i = 1; i <=10; i=i+2) {//循环多少次？？5
//					try {
//						Thread.sleep(500);
//					} catch (InterruptedException e) {
//						e.printStackTrace();
//					}
					System.out.println("奇数线程："+i);
				}
			}
		}
	}
}
class Thread102 extends Thread{//偶数
	@Override
	public void run() {
		while(true){//多次打印 五个数
			synchronized ("java") {
				for (int i = 2; i <=10; i=i+2) {//循环多少次？？5
//					try {
//						Thread.sleep(500);
//					} catch (InterruptedException e) {
//						e.printStackTrace();
//					}
					System.out.println("偶数线程："+i);
				}
			}
			
		}
	}
}

```

### **synchronized 线程安全大总结：**

总结1：多个线程访问同一个锁对象的代码块，同一时间只能有一个线程可以可以访问这个锁对象下的代码块，其他线程要访问同一个锁对象的代码块必须等待当前线程执行完这个代码块以后才能执行该代码块。锁只能管住（或者起作用）多个线程访问到同一个锁对象的代码块，（例如：我访问到这个锁对象下的代码块的时候，我会看看CPU上，是不是有这个锁对象下的代码在执行，有我就等待它执行完我在抢。反之（不是前面这个情况的我都抢），如果没有，或者其他的锁对象下的代码在执行，对不起不对我起作用，我只认我的锁对象，我还是要和你抢CPU。）

my:锁对象相当于一把锁，锁住了一间房间，锁对象下面的代码相当于房间里的资源，这个房间每次只能进入一个线程拿资源（ps:11.10日）

**每个类实例对应一把锁**，每个synchronized方法都必须获得调用该方法的类实例的锁方能执行，否则所属[线程阻塞](https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=71644860&ss_c=ssc.citiao.link)，方法一旦执行，就独占该锁，直到从该方法返回时才将锁释放，此后被阻塞的线程方能获得该锁，重新进入可执行状态。这**种机制确保了同一时刻对于每一个类实例，其所有声明为synchronized的成员函数中至多只有一个处于可执行状态（因为至多只有一个能够获得该类实例对应的锁）**

上面这段话解读：就是我在家里上厕所，不想被家人（同一个锁对象下的方法）打扰，我就把厕所锁上，这样家人就知道等我上完厕所后再用厕所，但是这把锁不对外人（小偷）起作用，外人来直接就把厕所门踹开了。



### 锁对象

**class Thread202 implements Runnable{}，实现接口传入同一个类实例，synchronized(this)这时候是同一个锁对象。**（三个线程操作的属性是同一个）

```java
	Thread202 t=new Thread202();
//		依然存在问题：线程不安全(暂时先不解决)
		//包装
		Thread t1=new Thread(t, "窗口A");
		t1.start();
		
		Thread t2=new Thread(t, "窗口B");
		t2.start();
		
		Thread t3=new Thread(t, "窗口C");
		t3.start();*/
```

**class Thread201 extends Thread{}，采用继承的方式synchronized (Thread201.class)，或者synchronized ("java") 才是同一个锁对象。**（三个线程由于对象不同操作的实例变量不是同一个，需要将num进行static）

```java
//创建三个线程    存在什么问题？各自都是100张票    
//		依然存在问题：线程不安全(暂时先不解决)
		//继承Thread的方式：需要将num进行static
		Thread201 t1=new Thread201("窗口A");
		t1.start();
		Thread201 t2=new Thread201("窗口B");
		t2.start();
		Thread201 t3=new Thread201("窗口C");
		t3.start();
```

###  Lock锁

* java.util.concurrent.locks.Lock 机制提供了比synchronized代码块和synchronized方法更广泛的锁定操作,同步代码块/同步方法具有的功能Lock都有,除此之外更强大,更体现面向对象。

* Lock锁也称同步锁，加锁与释放锁方法，如下：

  * public void lock() :加同步锁。
  * public void unlock() :释放同步锁。

```java
public class Ticket implements Runnable{
	private int ticket = 100;    
	Lock lock = new ReentrantLock();
	    
	/*	    
	 * 执行卖票操作    
	 */
	@Override	    
	public void run() {	    
		//每个窗口卖票的操作 	        
		//窗口 永远开启 	        
		while(true){        
			lock.lock();	            
			if(ticket>0){//有票 可以卖            
				//出票操作                 
				//使用sleep模拟一下出票时间                 
				try {                
					Thread.sleep(50);                    
				} catch (InterruptedException e) {                
				// TODO Auto‐generated catch block                    
					e.printStackTrace();                    
				}                
				//获取当前线程对象的名字                 
				String name = Thread.currentThread().getName();               
				System.out.println(name+"正在卖:"+ticket‐‐);	                
			}            
			lock.unlock();            
		}        
	}    
}
```

示例代码

```java
package com.atguigu.ThreadDemo;

import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * 此类用于演示    Lock 锁
 * 	线程安全--->效率肯定低
 * a. 同步代码块
 * 	synchronized(锁对象[多个线程必须是同一个对象]){需要上锁的代码}
 * b. 同步方法
 * 	b.1 实现Runnable接口的方式  在普通方法的修饰符位置加上  synchronized
 * 		public synchronized boolean test1(){}
 *  b.2 继承Thread类的方式    在普通方法的修饰符位置加上 static synchronized
 *  	public static synchronized boolean test1(){}
 * c. Lock锁
 * 	c.1  实现Runnable接口的方式
 * 		a. 在线程中创建一个Lock对象(锁对象)
 * 			Lock lock=new ReentrantLock();
 * 		b. 在需要上锁的代码上方，执行方法lock();
 * 		c. 在需要释放锁的位置下一行，执行unlock();[一定要放在finally中]
 * 		
 *  c.2 继承Thread类的方式
 *  	a. 在线程中创建一个静态的Lock对象(锁对象)
 * 			static Lock lock=new ReentrantLock();
 * 		b. 在需要上锁的代码上方，执行方法lock();
 * 		c. 在需要释放锁的位置下一行，执行unlock();[一定要放在finally中]
 * 
 * 脑子：这个我会了！
 * 手：不，你不会
 * 
 * 三个窗口卖票的去练习锁
 * 
 * 
 * 
 * 同一个账户，两个储户去取钱
 */

public class Demo2 {

	public static void main(String[] args) {
		Account account=new Account(1001,10000);
		
		/* 采用实现接口方式的启动
		 * */
		/*Thread11 t=new Thread11(account);
		
		Thread t1=new Thread(t);
		t1.start();
		Thread t2=new Thread(t);
		t2.start();*/
		
		/*
		 * 采用竭诚方式的启动
		 */
		Thread12 t1=new Thread12(account);
		t1.start();
		Thread12 t2=new Thread12(account);
		t2.start();
	}
}
//老师在试一下继承的方式有无问题
class Thread12 extends Thread{
	private static Account account;//需要设置为static
	//第一步锁对象建立
	private static Lock lock=new ReentrantLock();//因为不是同一把锁lock
	public Thread12(Account account) {
		super();
		this.account = account;
	}
	@Override
	public void run() {
		while(true){
			try {
				lock.lock();
				try {
					Thread.sleep(50);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				if(account.getMoney()<=0){
					System.out.println("没钱了。。。。");
					return;//结束当前方法(run方法)--->结束当前线程
				}
				account.setMoney(account.getMoney()-100);
				System.out.println(Thread.currentThread().getName()+"取了100块，剩余"+account.getMoney());
			} finally {
				lock.unlock();
			}
			
		}
	}
	
}
class Thread11 implements Runnable{
	private Account account;
	//1. 创建锁对象    如何上锁？  
	//在需要上锁的开头  lock.lock();    在末尾  lock.unlock();
	private Lock lock=new ReentrantLock();
	public Thread11(Account account) {
		super();
		this.account = account;
	}

	@Override
	public void run() {
		while(true){
			try{
				lock.lock();//从此位置开始上锁   发生了死锁问题！！死锁是一定要避免的
				try {
					Thread.sleep(50);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				if(account.getMoney()<=0){
					System.out.println("没钱了。。。。");
					return;//结束当前方法(run方法)--->结束当前线程
				}
				account.setMoney(account.getMoney()-100);
				System.out.println(Thread.currentThread().getName()+"取了100块，剩余"+account.getMoney());
			}finally{
				lock.unlock();
				//到这里结束    此时的死锁是由于return执行后，没有执行unlock方法
				//unlock一定要放在finally中 ***  finally是遇到return、break/异常...也会执行的区域
			}
		}
	}
	
	
}
```

### 死锁问题

```java
package com.atguigu.ThreadDemo;
/**
 * 此类用于演示    死锁
 *1. 死锁在开发过程中是必须要避免的
 *	a. Lock锁的死锁，unlock没有执行到
 *		将unlock放在finally中
 *	b. synchronized同步代码块
 *		两个线程会出现相互等待的效果，【要避免的问题】
 */
class Demo3 {

	public static void main(String[] args) {
		Thread101 t1=new Thread101();
		t1.start();
		Thread102 t2=new Thread102();
		t2.start();
	}
}
class Thread101 extends Thread{
	@Override
	public void run() {
		synchronized ("java") {
			for (int i = 0; i < 10; i++) {
				try {
					Thread.sleep(100);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				System.out.println("Thread101---"+i);
			}
			//在第一把锁的里面
			synchronized ("python") {
				System.out.println("也是要执行的代码。。。。");//没有输出
			}
		}
	}
}
class Thread102 extends Thread{
	@Override
	public void run() {
		synchronized ("python") {
			for (int i = 0; i < 10; i++) {
				try {
					Thread.sleep(100);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				System.out.println("Thread102---"+i);
			}
			//在第一把锁的里面
			synchronized ("java") {
				System.out.println("也是要执行的代码。。。。");//没有输出
			}
		}
	}
}
```

### 守护线程

```java
package com.atguigu.ThreadDemo;
/**
 * 此类用于演示 守护线程(了解)
 *  1. java中一个非常经典的守护线程就是  GC线程
 *  	守护其他线程：当前其他线程执行完毕，自己无论有没有执行完毕都立刻结束
 *  2. 如何设置为守护线程？
 *  	线程对象.setDaemon(true);
 *  	注意：设置守护线程一定要在线程启动之前
 */
public class Demo4 {
	public static void main(String[] args) {
		//将t2设置为守护线程  t2什么时候结束？
		Thread201 t1=new Thread201();
		t1.start();
		Thread202 t2=new Thread202();
		t2.setDaemon(true);//将t2设置为守护线程    只有t2是守护线程
		t2.start();
		
		for (int i = 0; i < 5; i++) {
			try {
				Thread.sleep(500);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			System.out.println("main---"+i);
		}
	}
}
class Thread201 extends Thread{
	@Override
	public void run() {
		for (int i = 0; i < 10; i++) {
			try {
				Thread.sleep(500);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			System.out.println("Thread201---"+i);
		}
	}
}
class Thread202 extends Thread{
	@Override
	public void run() {
		for (int i = 0; i < 15; i++) {
			try {
				Thread.sleep(500);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			System.out.println("Thread202++++"+i);
		}
	}
}
```

### 线程的生命周期

```java
package com.atguigu.ThreadDemo;
/**
 * 此类用于演示   线程的生命周期(线程从出生到死亡的过程)
 * 1. 新生线程
 * 	刚刚实例化出来的线程对象
 * 	Thread301 t=new Thread301();//此时的t就是新生线程
 * 2. 就绪线程(可运行线程)
 * 	调完start方法之后
 * 	t.start();//start方法执行完后，t就变成了就绪线程
 * 3. 运行线程(不需要程序员写什么代码)
 * 	调用完start方法之后，线程就去抢执行权，抢到后，才进入运行状态
 * 4. 阻塞线程
 * 	线程遇到阻塞了！
 * 	sleep睡眠
 * 	join线程的插队
 * 	wait等待
 * 	IO阻塞
 * 	...
 * 		如果阻塞结束，会进入到那个状态？  会进入到就绪状态
 * 5. 死亡线程
 * 	run方法运行完毕
 * 	调用stop方法(已过时，不建议使用)
 * 
 * 线程的通信  wait等待
 */
public class Demo5 {

	public static void main(String[] args) {
		Thread301 t=new Thread301();//此时的t就是新生线程
		t.start();//start方法执行完后，t就变成了就绪线程
	}
}

class Thread301 extends Thread{

	@Override
	public void run() {
		System.out.println("abcd....");
	}
	
}
```

### 线程的通信

```java
package com.atguigu.ThreadDemo;
/**
 * 此类用于演示   线程的通信
 * 	1. 线程等待 (暂停)    唤醒线程(恢复)
 * 		Object
 * 			obj.wait();   让线程等待的方法
 * 				注意：谁等待？是obj吗？不是obj等待，是运行wait方法的线程等待
 * 				"java".wait();   运行wait方法的线程，在对象的监视器"java"下等待
 * 				执行完wait方法会释放锁资源  ***
 * 			obj.wait(long timeout);  等待的同时，设置了时间
 * 			obj.wait(long timeout,long nanos);
 * 
 * 			obj.notify();唤醒在obj对象监视器下等待的单个线程
 * 			obj.notifyAll() ;唤醒在obj对象监视器下等待的所有线程
 * 		
 * my:	1.wait方法必须放在锁里面；
 * 		两个原因：
 * 			为什么？1》因为等待和唤醒只能运行一个   wait和notify方法能同时执行
			2》wait一旦有一个线程执行，就必须从头到尾执行完才可以
 * 		2.锁对象和对象监视器必須是同一个对象
 * 		3.誰都可以調wait方法，因爲wait是從object类继承的方法。
 * 		4.是运行wait方法的线程等待
 * 		5.执行完wait方法会释放锁资源 
 *  
 */
public class Demo6 {

	public static void main(String[] args) {
		
		Thread601 t1=new Thread601();
		t1.start();
		Thread601 t2=new Thread601();
		t2.start();
		
		for (int i = 0; i < 100; i++) {
			try {
				Thread.sleep(500);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			if(i==10){
				//肯定运行在子线程等待之后
				//唤醒等待的线程
				synchronized ("java") {
					//在"java"对象监视器下，等待两个线程
//					"java".notify();//谁去调用notify方法能够唤醒子线程呢？
//					"java".notifyAll();
				}
			}
			System.out.println("main--------"+i);
		}
	}
}
class Thread601 extends Thread{
	@Override
	public void run() {
		for (int i = 0; i < 100; i++) {
			try {
				Thread.sleep(500);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			if(i==5){//判断子线程运行到第五次时，让当前(子线程)线程等待
				//来自于 Object  继承后，讲过Object类  equals
				synchronized ("java") {//锁对象和对象监视器是同一个对象
					try {
						"java".wait(2000);//谁调？必须运行在锁里面    
						//为什么？因为等待和唤醒只能运行一个   wait和notify方法能同时执行
						//wait一旦有一个线程执行，就必须从头到尾执行完才可以
					} catch (InterruptedException e) {
						e.printStackTrace();
					}
				}
				
			}
			System.out.println(Thread.currentThread().getName()+"----"+i);
		}
	}
}
```

### 生产者和消费者的问题

```java
package com.atguigu.ThreadDemo;
/**
 * 案例演示
 *2. 生产者和消费者的问题
 *  	吃货(吃包子)  
 *  		判断现在是否有包子
 *  			有：  吃(吃完之后，会唤醒包子铺等待的线程，让生产包子的线程继续运行)
 *  			没有：   当前吃的线程要进行等待(等待包子铺去生产包子)
 *      包子铺(生产包子)
 *      	判断现在是否有包子
 *      		有：当前生产包子的线程进行等待(等待吃货去吃)
 *      		没有：  立刻去做(如果做完了，唤醒吃货的线程，让吃货去吃)
 */
public class Demo7 {

	public static void main(String[] args) {
		BaoZi baozi=new BaoZi();
		
		ChiHuo chihuo=new ChiHuo(baozi);
		chihuo.start();
		
		BaoZiPu baozipu=new BaoZiPu(baozi);
		baozipu.start();
				
	}
}
class ChiHuo extends Thread{
	private BaoZi baozi;
	
	public ChiHuo(BaoZi baozi){
		this.baozi=baozi;
	}
	@Override
	public void run() {
		while(true){//吃货无限的吃包子
			synchronized (baozi) {
				//1. 进行包子资源的判断
				if(baozi.isFlag()){
					//存在包子，开始吃就可以了
					System.out.println("吃货在吃"+baozi.getPer()+baozi.getXian()+"的包子");
					//吃货吃完了
					for (int i = 1; i <= 3; i++) {
						try {
							Thread.sleep(300);
						} catch (InterruptedException e) {
							e.printStackTrace();
						}
						System.out.println("吃第"+i+"口");
					}
					baozi.setFlag(false);
					//还有一件事情需要做？？？？唤醒包子铺进行包子制作
					baozi.notify();
				}else{
					//说明没有包子
					//应该进行等待
					try {
						baozi.wait();
					} catch (InterruptedException e) {
						e.printStackTrace();
					}
				}
			}
			
		}
	}
}
class BaoZiPu extends Thread{
	private BaoZi baozi;
	
	public BaoZiPu(BaoZi baozi) {
		this.baozi = baozi;
	}
	@Override
	public void run() {
		while(true){
			synchronized (baozi) {
				//判断包子资源是否存在
				if(baozi.isFlag()){
					//包子资源时存在的,包子铺进行等待操作
					try {
						baozi.wait();
						
					} catch (InterruptedException e) {
						e.printStackTrace();
					}
				}else{
					//包子不存在，包子铺开始制作包子
					System.out.println("包子铺正在制作包子。。。。");
					baozi.setPer("白面");
					baozi.setXian("猪肉大葱");
					
					baozi.setFlag(true);//包子制作成功
					for (int i = 3; i >0; i--) {
						try {
							Thread.sleep(300);
						} catch (InterruptedException e) {
							e.printStackTrace();
						}
						System.out.println("倒计时："+i);
					}
					//此处还要做一个事情？？？？？
					System.out.println("包子已完成！吃货快来吃！！！");
					//唤醒吃货
					baozi.notify();
				}
			}
		}
	}
	
}
class BaoZi{
	private String per;
	private String xian;
	
	private boolean flag;//包子资源是否存在   true存在  false不存在

	public BaoZi(String per, String xian) {
		super();
		this.per = per;
		this.xian = xian;
	}

	public BaoZi() {
		super();
		// TODO Auto-generated constructor stub
	}

	public String getPer() {
		return per;
	}

	public void setPer(String per) {
		this.per = per;
	}

	public String getXian() {
		return xian;
	}

	public void setXian(String xian) {
		this.xian = xian;
	}

	public boolean isFlag() {
		return flag;
	}

	public void setFlag(boolean flag) {
		this.flag = flag;
	}

	@Override
	public String toString() {
		return "BaoZi [per=" + per + ", xian=" + xian + "]";
	}
	
	
}
```

### sleep和wait的区别？

```java
package com.atguigu.ThreadDemo;
/**
 * 此类用于演示  释放锁内容
 * 1. sleep和wait的区别？
 * 	sleep不会释放锁资源
 * 	wait会释放锁资源
 *
 */
public class Demo8 {

	public static void main(String[] args) {
		
		Thread801 t=new Thread801();
		t.start();
		
		synchronized ("java") {
			for (int i = 0; i < 10; i++) {
				if(i==5){
					try {
//						Thread.sleep(2000);
						"java".wait();//子线程执行的时候，主线程执行完了吗？
						//是因为主线程执行完wait方法，会对所资源进行释放
					} catch (InterruptedException e) {
						e.printStackTrace();
					}
				}
				System.out.println("main-----------"+i);
			}
		}
	}
}
class Thread801 extends Thread{
	@Override
	public void run() {
		synchronized ("java") {
			for (int i = 0; i < 10; i++) {
				if(i==5){
					try {
//						Thread.sleep(2000);
						"java".wait();
					} catch (InterruptedException e) {
						e.printStackTrace();
					}
				}
				System.out.println("Thread801----"+i);
			}
		}
	}
	
}
```

