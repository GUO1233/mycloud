# 字符流+四大缓冲流+转换流+对象流（序列化）

## 字符输入流（存在一个缓冲区）

```java
package com.atguigu.IO;

import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.Reader;

import org.junit.Test;

/**
 * 此类用于演示的是  Reader
 */
public class Demo1 {

	/**
	 * 此方法演示字符输入流
	 * 	Reader   第一大子类  FileReader
	 * 	构造器：
	 * 		new FileReader(File file);
	 * 		new FileReader(String pathname);
	 *  常用方法：
	 *  	int read()  执行一次读取一个字符
	 *  	int read(char[] c) 执行一次讲读取的内容放在数组中，返回读取的字符数，如果没内容读取长度返回-1
	 		int read(char[] c,int off,int len) 讲读取的len个字符从数组的off索引位置开始存储
	 	练习：
	 		从d://aaa/aaa.txt  到程序，并在控制台打印
	 */
	@Test
	public void test3(){
		//1. 创建字符输入流的对象   存在一个缓冲区
		Reader reader=null;
		try {
			reader=new FileReader("d://testIO/1.txt");
			//2. 进行读的操作
			char[] c=new char[10];
			int len = reader.read(c, 2, 5);
			for (char d : c) {
				System.out.print(d);
			}
			System.out.println("-----------");
			System.out.println("长度="+len);
		} catch (Exception e) {
			e.printStackTrace();
		}finally{
			try {
				reader.close();
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
	}
	@Test
	public void test2(){
		//1. 创建字符输入流的对象   存在一个缓冲区
		Reader reader=null;
		try {
			reader=new FileReader("d://testIO/1.txt");
			//开始读的操作
			/*char[] c=new char[10];
			int len=reader.read(c);
			
			for (char d : c) {
				System.out.print(d);
			}
			System.out.println("-----");
			System.out.println(len);
			
			char[] c1=new char[10];
			int len1=reader.read(c1);
			System.out.println(len1);*/
			
			char[] c=new char[6];
			int len=0;
			while((len=reader.read(c))!=-1){
				for (char d : c) {
					System.out.print(d);
				}
			}
			
		} catch (Exception e) {
			e.printStackTrace();
		}finally{
			try {
				reader.close();
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
	}
	@Test
	public void test1(){
		//1. 创建字符输入流的对象   存在一个缓冲区
		Reader reader=null;
		try {
			reader=new FileReader("d://testIO/1.txt");
			//2. 进行读取操作
			/*int i = reader.read();
			System.out.println((char)i);*///有可能乱码
			//如果文档的字符集和程序的字符集一致就不会乱码
			//不一致就会乱码    如何解决乱码？后面会学习转换流
			/*  文件		 程序
			 *   utf-8   utf-8              一个中文字符是3个字节
			 * 	 gbk	 utf-8              一个中文字符是2个字节
			 */
			//去找循环结束的位置
			/*int j = reader.read();
			System.out.println(j);//读取不到内容返回-1
			 */		
			int i=0;
			while((i=reader.read())!=-1){
				System.out.print((char)i);
			}
			
		} catch (Exception e) {
			e.printStackTrace();
		}finally{
			try {
				reader.close();
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
	}
}
```

## 字符输出流 

```java
package com.atguigu.IO;

import java.io.FileWriter;
import java.io.IOException;
import java.io.Writer;

import org.junit.Test;

/**
 * 此类用于演示  Writer
 * @author 86152
 *
 */
public class Demo2 {

	/**
	 * 字符输出流  
	 *   Writer    第一大子类   FileWriter
	 *   构造器：
	 *   	new FileWriter(File file)
	 *   	new FileWriter(String pathName)
	 *   	new FileWriter(File file,boolean append)
	 *   	new FileWriter(String pathName,boolean append)
	 *   方法：
	 *   	write(int c);执行一次写入一个字符
	 *   	write(char[] c);执行一次将c数组中的所有字符写入
	 *   	write(char[] c, int off, int len);执行一次从数组的off索引位置开始写，写len个字符
	 		write(String str); 将字符串内容全部写入
	 		write(String str,int off,int len); 将字符串内容从off索引位置开始写，写len个
	 	练习：
	 		采用字符流完成一个文本文件的复制(字符流是不能够读写字节类型的文件的)
	 */
	@Test
	public void test1(){
		//1. 字符输出流的创建
		Writer writer=null;
		try {
			writer=new FileWriter("d://testIO/java.txt",true);
			//2. 进行写入操作
			writer.write(97);
			writer.write(98);
			
			char[] arrs={'尚','硅','谷','好'};
			writer.write(arrs);
			
			char[] arrs1={'p','u','b','l','i','c'};
			writer.write(arrs1, 1, 3);//ubl
			
			writer.write("老板该给涨工资了");
			
			writer.write("System", 2, 3);//ste
			Integer
			
		} catch (Exception e) {
			e.printStackTrace();
		}finally{
			//3. 关闭资源
			try {
				writer.close();
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
	}
}
```

## 字符流的刷新方法(输出流)

```java
package com.atguigu.IO;

import java.io.FileWriter;
import java.io.IOException;
import java.io.Writer;

import org.junit.Test;

/**
 * 此类用于演示      字符流的刷新方法(输出流)
 * 
 * 	flush();  将缓存区中的数据写入到文件中
 * 
 * 什么时候用flush?   写入一部分数据时，就flush一下[保证意外情况下更多的保存数据，效率提高]
 * 	如果写入的数据是20万条！
 * 
 * 		for(int i=0;i<20000;i++){
 * 			if(i%100==0){
 * 				writer.flush();
 * 			}
 * 			writer.write("好好学习，天天向上");
 * 		}
 * 
 * 		writer.close();
 * 什么时候用close?
 * 	最后流对象不用了，就用close方法！！！
 *	
 */
public class Demo3 {
	@Test
	public void test2(){
		try {
			Writer writer=new FileWriter("d://testIO/jdbc3.txt");
			/*writer.write("jdbc还是很重要的1111！");
			writer.flush();
			writer.write("jdbc还是很重要的2222！");
			writer.flush();*/
			
			writer.write("jdbc还是很重要的1111！");
			writer.close();//当资源关闭，后面就不能再用
			writer.write("jdbc还是很重要的2222！");
			writer.close();
			
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	@Test
	public void test1(){
		try {
			Writer writer=new FileWriter("d://testIO/jdbc1.txt");
			writer.write("jdbc还是很重要的1111！");
			writer.write("jdbc还是很重要的1111！");
			writer.write("jdbc还是很重要的1111！");
			writer.write("jdbc还是很重要的1111！");
			writer.write("jdbc还是很重要的1111！");
			writer.write("jdbc还是很重要的1111！");
			writer.write("jdbc还是很重要的1111！");
			//1. 将内容写道缓存区
			//2. 在刷新或者关闭的时候，才将缓存区中的数据写到文件中
			//我没有关闭资源       字节流不关闭是可以写入内容的
			writer.flush();//刷新 --> 将缓存区中的数据写到文件中
//			writer.close();
			
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}
```

## 处理流中的   缓冲流(提高字节流的效率)(四大缓冲流)

```java
package com.atguigu.IO;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;

import org.junit.Test;

/**
 * 此类用于演示处理流中的   缓冲流(提高字节流的效率)
 * 	处理流的目的就是   提高效率或者增加好用的方法
 * 字节输入缓冲流    对InputStream的处理
 * 	 BufferedInputStream
 * 		构造器：
 * 			new BufferedInputStream(InputStream in);对InputStream的处理
 * 			采用默认的缓冲流时多大的缓冲区？	 8192   1024*8	
 * 			new BufferedInputStream(InputStream in,int size);
 * 			自己制定缓存区的大小！
 * 		方法：
 * 			和InputStream中三个read方法含义一样
 * 			read()
 * 			read(byte[] b)
 * 			read(byte[] b,int off,int len)
 * 		如何提高的效率？
 * 			字节流:  每次操作一个字节
 * 			缓冲流:  多了一个字节数组
 * 
 * 			楼下快递小哥，送100个快递，拿一个快递送回家，在回去拿第二个...
 * 			    					拿一个快递，在拿第二个，
 * 	提高读的效率
 * 字节输出缓冲流  介绍
 * 		BufferedOutputStream   
 * 		构造器：
 * 			new BufferedOutputStream(OutputStream out) 对OutputStream进行处理
 * 			new BufferedOutputStream(OutputStream out,int size)
 * 		方法：   用法和字节输出流一致
 * 			write(int i);
 * 			write(byte[] b);
 * 			write(byte[] b,int off,int len);
 * 	
 * 字符输入缓冲流   效率也会提升，但是没有字节流提升的那么明显
 * 		增加了好用的方法
 * 		BufferedReader
 * 		构造器：
 * 			new BufferedReader(Reader reader)
 * 			new BufferedReader(Reader reader,int size)
 * 		方法：
 * 			int read()
 * 			int read(char[] c)
 * 			int read(char[] c,int off,int len)
 * 			String readLine(); 一次读一行，读到没有时返回null
 * 字符输出缓冲流
 *		BufferedWriter
 *		构造器：
 *			new BufferedWriter(Writer writer);
 *			new BufferedWriter(Writer writer,int size);
 *		方法：
 *			写入的五个方法和Writer写入的方法一致
 *			newLine()  换行的区别(兼容好点)
 */
public class Demo4 {
	@Test
	public void test7(){
		//1. 字符输出缓冲流的对象创建
		BufferedWriter out=null;
		try {
			out=new BufferedWriter(
					new FileWriter("d://testIO/python.txt"));
			//2. 进行写入的操作
			out.write("abcd");
//			out.write("\r\n");//换行  \n
			out.newLine();//换行操作
			out.write("dcba");
		} catch (Exception e) {
			e.printStackTrace();
		}finally{
			try {
				out.close();
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
	}
	/**
	 * 字符输入缓冲流
	 */
	@Test
	public void test6(){
		//1. 字符输入缓冲流对象的创建
		BufferedReader br=null;
		try {
			br=new BufferedReader(
					new FileReader("d://testIO/java.txt"));
			//2. 读取操作
			/*String readLine = br.readLine();
			System.out.println(readLine);
			String readLine1 = br.readLine();
			System.out.println(readLine1);
			String readLine2 = br.readLine();//如果读不到了，返回null
			System.out.println(readLine2);*/
			String str=null;
			while((str=br.readLine())!=null){
				System.out.println(str);
			}
		} catch (Exception e) {
			e.printStackTrace();
		}finally{
			try {
				br.close();
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
	}
	
	
	//采用缓冲流流去进行一个不大不小的文件复制
	@Test
	public void test5(){
		long start=System.currentTimeMillis();
		//1. 流对象的创建
		BufferedInputStream bin=null;
		BufferedOutputStream bout=null;
		try {
			bin=new BufferedInputStream(
					new FileInputStream("d://testIO/abc.wmv"));
			bout=new BufferedOutputStream(
					new FileOutputStream("d://bbb/cba2.wmv"));
			//2. 读写操作
			byte[] b=new byte[1024];
			int len=0;
			while((len=bin.read(b))!=-1){
				bout.write(b, 0, len);
			}
		} catch (Exception e) {
			e.printStackTrace();
		}finally{
			//3. 关闭资源
			try {
				bin.close();
				bout.close();
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
		long end=System.currentTimeMillis();//
		System.out.println("程序运行时间："+(end-start));//66 ms
	}
	//采用缓冲流流去进行一个不大不小的文件复制
	@Test
	public void test4(){
		long start=System.currentTimeMillis();
		//1. 流对象的创建
		BufferedInputStream bin=null;
		BufferedOutputStream bout=null;
		try {
			bin=new BufferedInputStream(
					new FileInputStream("d://testIO/abc.wmv"));
			bout=new BufferedOutputStream(
					new FileOutputStream("d://bbb/cba1.wmv"));
			//2. 读写操作
			int i=0;
			while((i=bin.read())!=-1){
				bout.write(i);
			}
		} catch (Exception e) {
			e.printStackTrace();
		}finally{
			//3. 关闭资源
			try {
				bin.close();
				bout.close();
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
		long end=System.currentTimeMillis();//
		System.out.println("程序运行时间："+(end-start));//655 ms   还可以更快
		
		
	}
	
	//采用字节流去进行一个不大不小的文件复制
	@Test
	public void test3(){
		long start=System.currentTimeMillis();//获取1970-1-1到此时此刻的毫秒数
		//1. 流对象的创建
		InputStream in=null;
		OutputStream out=null;
		try {
			in=new FileInputStream("d://testIO/abc.wmv");
			out=new FileOutputStream("d://bbb/cba.wmv");
			//2. 读写操作
			int i=0;
			while((i=in.read())!=-1){
				out.write(i);
			}
			
		} catch (Exception e) {
			e.printStackTrace();
		}finally{
			//3. 关闭资源
			try {
				in.close();
				out.close();
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
		long end=System.currentTimeMillis();//
		System.out.println("程序运行时间："+(end-start));//178335 ms
	}
	
	@Test
	public void test2(){
		//1. 字节输出缓冲流的对象创建
		BufferedOutputStream bos=null;
		try {
			bos=new BufferedOutputStream(
					new FileOutputStream("d://testIO/oracle.txt"));
			
			//2. 进行写入操作
			bos.write(97);
			bos.write(98);
			bos.write(99);
			bos.write(100);
			
		} catch (Exception e) {
			e.printStackTrace();
		}finally{
			try {
				//3. 关闭资源(此时只需要关闭外层就可以)
				bos.close();
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
	}

	@Test
	public void test1(){
		//1. 字节输入缓冲流的对象创建      对InputStream的处理
		InputStream in=null;
		BufferedInputStream bin=null;
		try {
			in = new FileInputStream("d://testIO/1.txt");
			bin=new BufferedInputStream(in);
			
			int read = bin.read();
			System.out.println((char)read);
		} catch (Exception e) {
			e.printStackTrace();
		}finally{
			//3. 关闭资源
			try {
				in.close();
				bin.close();
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
		
	}
}
```

## 转换流  (处理流)（字节---->字符）

```Java
package com.atguigu.IO;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.Reader;
import java.io.Writer;

import org.junit.Test;

/**
 * 此类用于演示   转换流  (处理流)
 * 	字节流  --->   字符流
 * 		字节输入流---->字符输入流
 * 		字节输出流---->字符输出流
 *  转换流功能：
 *  	a. 字节流转为字符流
 *  	b. 在转换的过程中可以指定字符集
 *  字节输入流---->字符输入流(并且设置字符集)
 *  字节输出流---->字符输出流
 *  
 *  练习：
 *  	有一个文本文档格式是GBK,程序是UTF-8,将该文件内容读到程序中并打印！
 *  	打印的同时，在讲内容按照UTF-8的形式写到另外一个文本文档中
 *  	
 */
public class Demo5 {
	/**
	 * 字节输出流---->字符输出流
	 * OutputStreamWriter
	 * 	构造器：
	 * 		new OutputStreamWriter(out) 采用和程序相同的字符集转换
	 * 		new OutputStreamWriter(out,String charsetName)
	 */
	@Test
	public void test3(){
		try {
			OutputStream out=new FileOutputStream("d://testIO/linux1.txt");
			Writer writer=new OutputStreamWriter(out,"GBK");
			writer.write("你好，hello");//（my:写的时候是采用GBK对字节流进行编码）
			
			writer.close();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
	/**
	 * 字节输入流---->字符输入流(并且设置字符集)
	 * InputStreamReader
	 * 	构造器：
	 * 		new InputStreamReader(InputStream in)单纯的将字节流转为字符流，并没有设置字符集（采用的是程序的字符集）
			new InputStreamReader(InputStream in,String charsetName)将字节流转为字符流，并设置字符集
	 	
	 */
	@Test
	public void test2(){
		try {
			InputStream in=new FileInputStream("d:/testIO/2.txt");
			//in转为字符流，2.txt是GBK格式，程序要采用UTF-8的格式去读
			//单纯的将字节流转为字符流，并没有设置字符集（采用的是程序的字符集）
			Reader r=new InputStreamReader(in,"GBK");//采用GBK的格式去转换成字符流（my:格式要和要和读取文件的格式保持一致）
//			GBK解码   字节-->字符
			int read = r.read();//（my:读的时候是采用GBK对字节流进行解码）
			System.out.println((char)read);
			
			in.close();
		} catch (Exception e) {
			e.printStackTrace();
		}
		
		
	}
	/**
	 * 由于编码格式不一致导致的乱码演示
	 */
	@Test
	public void test1(){
		try {
			//程序是UTF-8     2.txt 是  GBK
			Reader in=new FileReader("d:/testIO/2.txt");
			int read = in.read();
			System.out.println((char)read);
			
			in.close();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}
```

#  对象流  (序列化的技术)

```Java
package com.atguigu.IO;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;

import org.junit.Test;

import com.atguigu.bean.Person;

/**
 * 此类用于演示  对象流  (序列化的技术)
 *	序列化：将java中的一个对象(运行内存)，按照字节序列的方式写到一个文件(磁盘)中
 *	反序列化：将文件中的对象，在读到程序中
 *  对象流(处理流的一种:只对字节流处理，不对字符流处理)
 *  
 * 字节输出对象流 (序列化)
 * 
 * 字节输入对象流 (反序列化)
 * 
 * serialVersionUID的功能是什么？
 * 	不加该id一样序列化
 * 	功能：考虑版本的兼容性
 */
public class Demo6 {
	/**
	 * 字节输入对象流 (反序列化)
	 *    ObjectInputStream
	 *   构造器：
	 *   	new ObjectInputStream(InputStream in)
	 *   方法：
	 *   	int read();
	 *   	int read(byte[] b)
	 *   	int read(byte[] b,int off,int len)
	 *   
	 *   	XXX readXXX();
	 *   	Object readObject();
	 *   
	 *   注意事项：
	 *   	1. 为什么必须按照顺序读？
	 *   		因为不同数据的字节数不同
	 *   	2. 我怎么知道他的顺序？(一个文件要么放一个类型的对象，一个该对象的集合)
	 *   	3. 序列化有什么用？ (自己序列化，自己反序列化)
	 *   		jvm是存在垃圾回收机制！没有引用的对象就会在某个时刻被回收
	 *   			所有的对象都有引用！但是快把运行内存占满了！(序列化到硬盘)
	 *   			
	 */
	@Test
	public void test2(){//直接读
		//对象的创建
		ObjectInputStream in=null;
		try {
			in=new ObjectInputStream(
					new FileInputStream("d://testIO/person.txt"));
			//2. 读取(必须按照写入的顺序去读)
			double readDouble = in.readDouble();//读8个字节
			System.out.println(readDouble);
			String readUTF = in.readUTF();//读6个字节
			System.out.println(readUTF);
			Object readObject = in.readObject();//20字节
			System.out.println(readObject);
		} catch (Exception e) {
			e.printStackTrace();
		}finally{
			//3. 关闭资源
			try {
				in.close();
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
	}
	/**
	 * 字节输出对象流 (序列化)
	 * ObjectOutputStream
	 * 构造器：
	 * 	new ObjectOutputStream(OutputStream out);
	 * 方法：
	 * 	write(int i);
	 *  write(byte[] b);
	 *  write(byte[] b,int off,int len)
	 *  
	 *  writeXXX(XXX xx)  各种种类的写入方法
	 *  writeObject(Object obj)  写入任意对象
	 */
	@Test
	public void test1(){
		ObjectOutputStream oos=null;
		try {
			//1.对象流创建
			oos=new ObjectOutputStream(
					new FileOutputStream("d://testIO/person.txt"));
			
			//2. 进行写的操作
			Person per=new Person(1, "阳阳", 18);
			
			oos.writeDouble(100.5);//  8个字节
			oos.writeUTF("你好");//  6个字节
			oos.writeObject(per);//序列化的数据，需要实现一个接口  //假设20个字节
			//写入成功之后，打开文件，不可读(因为是一个字节序列)
		}  catch (Exception e) {
			e.printStackTrace();
		}finally{
			//关闭资源
			try {
				oos.close();
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
	}

}


package com.atguigu.bean;

import java.io.Serializable;

public class Person implements Serializable{

	/**
	 * 标记版本，提高版本的兼容性
	 */
	private static final long serialVersionUID = 1L;
	private int id;
	private String name;
	private int age;
	//在此改变版本
	private String address;
	public Person(int id, String name, int age) {
		super();
		this.id = id;
		this.name = name;
		this.age = age;
	}
	public Person(int id, String name, int age, String address) {
		super();
		this.id = id;
		this.name = name;
		this.age = age;
		this.address = address;
	}
	public int getId() {
		return id;
	}
	public void setId(int id) {
		this.id = id;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public int getAge() {
		return age;
	}
	public void setAge(int age) {
		this.age = age;
	}
	public String getAddress() {
		return address;
	}
	public void setAddress(String address) {
		this.address = address;
	}
	@Override
	public String toString() {
		return "Person [id=" + id + ", name=" + name + ", age=" + age + ", address=" + address + "]";
	}
	
	
}

```

## 练习

```java
package com.atguigu.test;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.Reader;
import java.io.UnsupportedEncodingException;
import java.io.Writer;

import org.junit.Test;

/**
 * 有一个文本文档格式是GBK,程序是UTF-8,将该文件内容读到程序中并打印！
 *  	打印的同时，在讲内容按照UTF-8的形式写到另外一个文本文档中
 * @author 86152
 *
 */
public class Test2 {

	@Test
	public void test1(){
		Reader in=null;
		Writer out=null;
		try {
			//1. 流对象的创建
			in=new InputStreamReader(
					new FileInputStream("d://testIO/2.txt"),"GBK");
			out=new OutputStreamWriter(
					new FileOutputStream("d://bbb/2222.txt"));
			//2. 读写操作
			char[] c=new char[10];
			int len=0;
			while((len=in.read(c))!=-1){
				System.out.println(new String(c, 0, len));
				out.write(c,0,len);
			}
			
		} catch (Exception e) {
			e.printStackTrace();
		}finally{
			//3. 关闭资源
			try {
				in.close();
				out.close();
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
	}
}

```

```java
package com.atguigu.test;

import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.Reader;
import java.io.Writer;

import org.junit.Test;

/**
 * 采用字符流完成一个文本文件的复制(字符流是不能够读写字节类型的文件
 *
 */
public class Test1 {

	@Test
	public void test1(){
		//1. 流对象的创建
		Reader reader=null;
		Writer writer=null;
		try {
			reader=new FileReader("d://testIO/java.txt");
			writer=new FileWriter("d://bbb/python2.txt");
			//2. 进行读写操作(1)
			/*int i=0;
			while((i=reader.read())!=-1){
				writer.write(i);
			}*/
			// 2. 进行读写操作(2)
			/*char[] c=new char[10];
			int len=0;
			while((len=reader.read(c))!=-1){
				writer.write(c,0,len);
			}*/
			// 2. 进行读写操作(3)
			char[] c=new char[10];
			int len=0;
			while((len=reader.read(c))!=-1){
				writer.write(new String(c, 0, len));
			}
			
		} catch (Exception e) {
			e.printStackTrace();
		}finally{
			//3. 资源的关闭
			try {
				reader.close();
				writer.close();
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
	}
}
```

